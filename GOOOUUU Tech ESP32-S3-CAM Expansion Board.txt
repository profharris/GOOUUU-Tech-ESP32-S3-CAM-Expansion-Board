GOOUUU Tech ESP32-S3-CAM Expansion Board

.____________________________________________________________________________________.
| Ø    ___  ¬R4        1 2 3 4      ¬R6   .-----------.    U2                      Ø |
|     |W Ø|        GND • • • •           —ô 5V0 sensor|    Ø¨¨[•|ô|o|o]¨¨Ø    I²C    |
| 5V0 |5  | o      5V0 ô ô ô ô  o     G2 —oDATA DHT11 |    ¦   G V S S   ¦ ————————— |
|     |0  | o G5   SIG o o o o  o G4     —× n/c temp  |    ¦   N C C D   ¦ GND > GND |
| GND |5  | P7         G G G G  P8       —• GND humi  |    ¦   D C L A   ¦ VCC > 5V0 |
|     '———'            1              U3  '-----------'    ¦             ¦ SCL > G9  |
|   R3 POT                _______________                  ¦ 0.96″ OLED  ¦ SDA > G8  |
|                        |  ___   _   __¯|    G##~ SD_Card ¦   64×128    ¦           |
|     DVP Camera _G##    | | | |_| |_|   |    G##* PSRAM   Ø……¨¨¨¨¨¨¨¨………Ø           |
|                     .——| | |           |——.                                        |
|TXD o ö 3V3      3V3 |ö:|——.··. .————/:@|:o| G43  TX›        _____SPI TFT___ESP32S3_|
|RXD o o EN       RST |o:|  WiFi ß    '——|:o| G44  RX‹        | 1. T_IRQ       ×     |
| G1 o © G4      _G4  |©:|  ˜¨¨˜ °       |:o| G1       T_CS   | 2. T_DO        G41   |
| G2 o © G5      _G5  |©:| ESP32S3-N16R8 |:o| G2       T_DIN  | 3. T_DIN       G2    |
|G42 o © G6      _G6  |©:|          ____ |:o| G42      T_CLK  | 4. T_CS        G1    |
|G41 o © G7      _G7  |©:| ŒÆ F©   |QRCD||:o| G41      T_DO   | 5. T_CLK       G42   |
|G40 õ © G15     _G15 |©:| ° N16R8 |____||:õ| G40~ SD_DATA    | 6. SDO<MISO>   GND   |
|G39 õ © G16     _G16 |©:'———————————————':õ| G39~ SD_CLK     | 7. LED/BL      3V3   |
|G38 õ © G17     _G17 |© ._______________. õ| G38~ SD_CMD     | 8. SCK         G0    |
|G37 ð © G18     _G18 |© | ::::::::::::: | ð| G37* PSRAM      | 9. SDI<MOSI>   G45   |
|G36 ð © G8      _G8  |© |    Camera     | ð| G36* PSRAM      |10. DC/RS       G47   |
|G35 ð o G3       G3  |o ¯¯:::::::::::::¯¯ ð| G35* PSRAM      |11. RESET       G21   |
| G0 o o G46      G46 |o      GOOUUU       o| G0  [BOOT] SCK  |12. CS          G14   |
|G45 o © G9      _G9  |©   ESP32-S3-CAM    o| G45       MOSI  |13. GND         GND   |
|G48 ¤ © G10     _G10 |©   ¬ ¬     ¤ ¤ [¤] ¤| G48  RGB        |14. VCC         5V0   |
|G47 o © G11     _G11 |©   ¨ ¨   PWR TX 48 o| G47         DC  '——————————————————————|
|G21 o © G12     _G12 |©      ......       o| G21        RST                         |
|G20 o © G13     _G13 |© RST |CH304G| BOOT ø| G20  D—           GOOUUU               |
|G19 o o G14  CS  G14 |o [Ø]  ''''''   [Ø] ø| G19  D+      (ESP32-S3-CAM) V1.2       |
|GND • ô 5V0      5V0 |ô .......O T....... •| GND        2.8″ SPI TFT LCD 240×320    |
|                     |  | USB |T T| USB |  |                                        |
|G46: In Only*        |  |  C  |G L|  C  |  |                   M     M T   T   T    |
|                     '——'ESP32'———'CH343'——'         V G   R   O S L I C T D T I    |
|          ¬   ¬                 .     .   ¬          C N C S D S C E S L C I D R    |
|          ¤   ¤      [Ø]   [Ø]  |USB-C|   ¤          C D S T C I K D O K S N O Q    |
| Ø       D2  D3      RST   KEY  '-----'  D1         [ô|•|o|o|o|o|o|ö|•|o|o|o|o|×] Ø |
'————————————————————————————————————————————————————————————————————————————————————'
 Pinout:   G   G       E     G             G          5 G G G G G G 3 G G G G G ×
           2   3       N     0             1          V N 1 2 4 4 0 V N 4 1 2 4
                                                      0 D 4 1 7 5   3 D 2     1 '-IRQ
                                                                    |   | | | '-MISO
——————————————————————————————————————————————————————————————————— |   | | '-MOSI
KEY FEATURES OF TFT LCD 2.8″ 240×320 DISPLAY WITH TOUCHSCREEN:      |   | '-CS  Touch
                                                                    |   '-SCK    Pins
    o 2.8″ TFT LCD with 240×320 resolution                          |
    o 65K colors with ILI9341 controller                            |
    o Resistive Touch Screen with XPT2046 controller                '-BackLight
    o SPI 4-wire LCD interface (SCK, MOSI, DC, CS)
    o SPI 4-wire SD_Card interface (SCK, MOSI, MISO, CS)
    o 3.6 to 5.5V module operation
    o 3.3V logic compatible only

These full color displays are large enough for many applications
even when using Touch.  The supplied stylus is helpful when using
smaller touch targets.

The modules have an SD_Card socket.  This socket has separate
connections to the opposite end of the board. Not needed with the
“ESP32-S3-CAM”, as it already has a TF SD_Card on the backside.

Internally the display operates at 3.3V, so if using with a 5V0
microcontroller, be sure to include logic level shifters on the
data lines to prevent possible damage.

————————————————————————————————————————————————————————————————————
QUICK NOTE: This GOOUUU Tech ESP32-S3-CAM Expansion Board has TWO
            sets of header pin sockets (Yellow and Black) to plug in
            ESP32-S3-WROOM-1 Development MCUs.

            The 40-Pin “Yellow” header sockets, are designed for the
            GOOUUU “ESP32-S3-CAM” board. The “ESP32-S3-WROOM” (CAM
            Module), a clone of the “FREEVOVE ESP32-S3-WROOM”; both
            also work in the “Yellow” headers as all three of these
            DVP camera ready dev boards have the same pinouts and
            same SoC main chip the “ESP32-S3-WROOM-1”.

            A fourth development board using the “ESP32-S3-WROOM-1”
            SoC, the “YD-ESP32-S3” also called the “ESP32-S3-WROOM-1
            Dev”, -is a 44-pin board, but the top and bottom rows of
            pins are just an extra 3V3 pin and three extra ground
            pins. This board also works in the “Yellow” header pin
            sockets... just let the extra top and bottom pins hang
            over the headers -alowing a 44-pin board to plug into a
            set of 40-pin sockets. This development board does not
            have a DVP camera interface like the first three boards.

            All 4 of these “ESP32-S3-WROOM-1” dev boards are pinout
            -backward compatible, not counting the extra top/bottom
            pins, with the original 44-pin “ESP-S3-DevKitC-1”.

            Unfortunately, this original “ESP-S3-DevKitC-1” will not
            plug into the “Yellow” headers as this original board is
            narrower (by 1 pin spacing) than the other four boards.
            Otherwise it could plug in just like the “YD-ESP32-S3”.

            NOTE: To identify one of these five ESP32-S3-DevKitC-1
            pin compatible boards... look at the board with the two
            USB ports facing down. The Left side pins will end with
            GPIO13, GPIO14 then 5V (and possibly an extra GND). The
            top of the Right side pins will (possibly start with GND)
            then begin with TXD, RXD, GPIO1, then GPIO2.

            The 44-pin “YD-ESP32-S3” and “ESP32-S3-DevKitC-1” have 1
            extra pin at the top and bottom, -an extra 3V3 in the
            upper-left, and an extra GND pin on the other 3 corners.
            --------------------------------------------------------

            The 42-Pin “Black” header sockets are for an ALT version
            of the “ESP-S3-DevKitC-1”. This ALT version has 42pins
            instead of the original 44-pins and is 1 pin space wider
            like the three dev boards mentioned above.

            Even though this 42-pin “ESP-S3-DevKitC-1_ALT-version”
            uses the same “ESP32-S3-WROOM-1” SoC, pinout is similar
            but NOT the same as the other 40/44-pin dev boards...
            “ESP32-S3-GOOUUU-CAM”, “ESP32-S3-WROOM” (CAM Module),
            “FREEVOVE ESP32-S3-WROOM”, “YD-ESP32-S3”, and original
            44-pin “ESP-S3-DevKitC-1”.

            A quick way to identify this dev board, besides 42-pins
            instead of 40 or 44-pins, is to look at the board with
            the two USB ports facing down. The upper-right pins will
            start with (extra) GND, GPIO1, GPIO2, TX0, RX0... and
            the lower-left will end with GPIO11, GPIO12, 3V3. AND
            importantly, the lower-right pin is ‘5VIN’.

WARNING: I want to pointout this lower-right ‘5VIN’ pin specifically
    because all the other ESP32-S3 Dev boards mentioned, have a GND
    (power ground) pin in the lower-right. Plugging in a 5V pin into
    a GND header socket, or vice-versa, is a quick way to short out
    and burn-up your dev board!

Now the design engineers of the “GOOUUU Tech ESP32-S3-CAM Expansion
Board” have done something very clever. They have cross-wired, were
needed, the pins in the 40-pin “Yellow” header to the 42-pin “Black”
header to match the pinout functions.

For example, the first four upper-right pins of the 40-pin “Yellow”
header are: 1. TXD, 2. RXD, 3. GPIO1, 4. GPIO2.  The first five pins
of the 42-pin “Black” header are 1. GND, 2. GPIO1, 3. GPIO2, 4. TX0,
and 5. RX0. The copper traces on the board connect Yellow pin-1 TXD
to Black pin-4 TX0, and Yellow pin-2 RXD to Black pin-5 RX0. Also
GPIO1 is cross connected to GPIO1, GPIO2 is cross connected to GPIO2
and so on. Since all the “ESP32-S3-WROOM-1” SoC designs have the
same pins this allows for a single 40-pin double row breakout header
along the left side of the expansion board. The pinout of the break
out header mirror-image matches the 40-pin “Yellow” headers, and all
pins are well marked.

————————————————————————————————————————————————————————————————————
Following is my diagram, illustrating the 2-way ESP32-S3-WROOM-1
Development board 40-pin “Yellow” and 42-pin “Black” header sockets.

 1. Pins marked © and _, are pins reserved for the DVP Camera.
    (Most all of the GPIO Pins on the left side header, except:
     GPIO3, GPIO46, and GPIO14)
 2. Pins marked õ and ~, are pins reserved for the TF SD_Card.
    (GPIO38, GPIO39, and GPIO40)
 3. Pins marked ð and *, are pins reserved for PSRAM and Flash.
    (GPIO36, GPIO37, and GPIO38)

 4. Pins marked ô are 5V0
 5. Pins marked ö are 3V3
 6. Pins marked • are GND
 7. Pins marked ø are USB_D+ and USB_D—
 
 8. Pins marked » or « are pin position mismatches between the 
    Yellow P1 & P2 header pin sockets and the Black P3 & P3 sockets.


        |ESP32-S3-DevKitC-1 |
        | 42pin ALT VERSION |
        V   Black P3 & P4   V

       |GOOUUU ESP32-S3-CAM|
       |   Yellow P1 & P2  |
       V                   V

       .—P1 (Yellow)       .—P2
       |.—P3 (Black)       |.—P4
       ||                  ||
        • GND               • GND
  3V3  öö 3V3 same    »TXD oo G1«
   EN  oo EN  same    »RXD oo G2«
  _G4  ©© G4  same    »G1  oo TX0«
  _G5  ©© G5  same    »G2  oo RX0«
  _G6  ©© G6  --same-- G42 oo G42
  _G7  ©© G7  --same-- G41 oo G41
  _G15 ©© G15 --same-- G40 õõ G40
  _G16 ©© G16 --same-- G39 õõ G39
  _G17 ©© G17 --same-- G38 õõ G38
  _G18 ©© G18 --same-- G37 ðð G37
  _G8  ©© G8  --same-- G36 ðð G36
  »G3  oø G19« D+ same G35 ðð G35
  »G46 oø G20« D— same G0  oo G0
 »_G9  ©o G3«     same G45 oo G45
 »_G10 ©o G46«    same G48 ¤¤ G48
 »_G11 ©© G9«     same G47 oo G47
 »_G12 ©© G10«    same G21 oo G21
 »_G12 ©© G10«    same G21 oo G21
 »_G13 ©© G11«     D— »G20 øo G14«
  »G14 o© G12«     D+ »G19 ø© G13«
  »5V0 ôö 3V3«        »GND •ô 5VIN«
       ||                  ||
       |'—Black            |'—Black
       '—Yellow            '—Yellow

————————————————————————————————————————————————————————————————————
GOOUUU Tech ESP32-S3-CAM Expansion Board
MISC Pin configurations:

DHT11 DATA: GPIO2



————————————————————————————————————————————————————————————————————
2.8″ TFT Display Technical Specifications:

Module Power

SEE IMAGE:  TFT LCD 2.8 240×320 RGB ILI9341 with Touchscreen
            - J1 Jumper Location

The module power comes in on the VCC pin.  The module includes an
on-board 3.3V regulator, so the module should normally be operated
with 3.6 to 5.5V power on this pin to feed the regulator.  Current
draw is typically 55-60mA.

If you would prefer to operate the module directly from a 3.3V power
source, there are two solder pads labeled J1.  By solder shorting
these two pads together, the regulator is bypassed and the module
can be powered directly from 3.3V.

In general, it is best to operate the display off of 5V to ensure
enough power is available.  Be careful of trying to operate the
display from the built-in 3.3V available on Arduino and similar
microcontrollers since these power sources often have limited
current capability and may overheat.

SPI Interface:

This display incorporates a SPI interface which provides for fast
display updates. It is a 4-wire interface so it includes the CS
(Chip Select) pin.

The Touch Screen also uses the SPI interface and can hook up to the
same pins as the display, but uses a separate CS to avoid conflict.

For best performance a hardware SPI interface should be used if
possible to get the fastest screen updates.

        Display	Technology	TFT LCD
                Resolution	240×320 pixels
                     Color	RGB 65K color (5:6:5)
             Viewing Angle  ±60°
                 Interface	SPI (Display and Touch)
         Operating Ratings	DC Power Input	3.6 – 5.5V
         Operating Current	<60mA (typical)

    Dimensions:
          Module Size (PCB)	86×50mm (3.39″×1.97″)
           Display diagonal	71.12mm (2.8″)
              Display (W×H)	57.6×43.2mm (2.27×1.7″)

    Display Controller	ILITEK	ILI9341
      Touch Controller	XPT	XPT2046

TFT 1x14 Header:

 1. T_IRQ – Touch Interrupt Output.  Active LOW. If using, connect
            to interrupt capable pin on MCU.
 2. T_DO  – Touch Read Data.  Connect to SPI MISO on MCU.
 3. T_DIN – Touch Write Data. Connect to SPI MOSI on MCU.
 4. T_CS  – Touch Chip Select must be a separate CS from the LCD CS.
 5. T_CLK – Touch SPI CLock.  Connect to SPI SCK  on MCU
 6. SDO(MISO) – Display SPI Read Data. Connect to SPI MISO on MCU
 7. LED   – LED BackLight Control.  HIGH = BackLight On.  Connect to
            3.3V if always ON or can be logic controlled.
 8. SCK   – Display SPI Clock. Connect to SPI SCK (Clock)
 9. SDI(MOSI) – Display SPI Write Data. Connect to SPI MOSI on MCU
10. DC    – Data or Command.  LOW = Command, HIGH = Data
11. RESET – Reset input active LOW.  Pull to 3.3V if not using
12. CS    – Display Chip Select.  This is the SPI Chip select for
            the LCD display
13. GND   – Connect to system ground.  This ground needs to be in
            common with the MCU.
14. VCC   – Connect to 3.6 to 5.5V.  Typically connected to the MCU
            or can be separate power supply.


Display Orientation:

The display can be rotated in all 4 directions.  Use setRotation(n)
to rotate the image to match the physical rotation where n ranges
from 0 to 3.

You will also need to set the rotation of the Touch Screen.  The
numbers DO NOT MATCH, so use one of the following combinations.

ILI9341 Display	 XPT2046 Touchscreen
    0	            2
    1	            3
    2	            0
    3	            1

————————————————————————————————————————————————————————————————————

====================================================================
// Find the default SPI pins for your board.
// Make sure you have the right board selected in: Tools > Boards...

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
  Serial.print("MOSI: ");
  Serial.println(MOSI);
  Serial.print("MISO: ");
  Serial.println(MISO);
  Serial.print("SCK: ");
  Serial.println(SCK);
  Serial.print("SS: ");
  Serial.println(SS);
}

void loop() {
  // put your main code here, to run repeatedly:
}

====================================================================

====================================================================
/* 240×320 ILI9341 LCD with Touch Test Program
 *
 * Exercise the 240×320 ILI9341 TFT LCD with touch
 * Based loosely on Adafruit mandelbrot example
 *
 */
#include "SPI.h"
#include "Adafruit_GFX.h"
#include "Adafruit_ILI9341.h"
#include "XPT2046_Touchscreen.h"

#define TFT_CS   10
#define TFT_DC   9
#define TOUCH_CS 8
Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC);
XPT2046_Touchscreen ts(TOUCH_CS);

const int16_t
  bits        = 12,     // Fractional resolution
  pixelWidth  = 320,    // TFT dimensions
  pixelHeight = 240,
  iterations  = 30;     //  Fractal iteration limit or 'dwell'
float
  centerReal  = -0.6,   // Image center point in complex plane
  centerImag  =  0.0,
  rangeReal   =  3.0,   // Image coverage in complex plane
  rangeImag   =  3.0;

boolean istouched = false;

//  Initialization

void setup(void) {
  Serial.begin(115200);
  Serial.println("Mandelbrot - Tap screen to increase zoom");

  tft.begin();                      // Init TFT LCD screen
  tft.setRotation(1);
  tft.fillScreen(ILI9341_BLACK);
  ts.begin();                       // Init Touch
  ts.setRotation(3);
}

//  Main

void loop() {
  int64_t     n, a, b, a2, b2, posReal, posImag;
  uint32_t    startTime, elapsedTime;

  int32_t
    startReal = (int64_t)((centerReal - rangeReal * 0.5)   * (float)(1 << bits)),
    startImag = (int64_t)((centerImag + rangeImag * 0.5)   * (float)(1 << bits)),
    incReal   = (int64_t)((rangeReal / (float)pixelWidth)  * (float)(1 << bits)),
    incImag   = (int64_t)((rangeImag / (float)pixelHeight) * (float)(1 << bits));

  startTime = millis();   // Calculate how long it takes to create an image
  posImag   = startImag;
  for(int y=0; y < pixelHeight; y++) {
    posReal = startReal;
    for(int x=0; x < pixelWidth; x++) {
      a = posReal;
      b = posImag;
      for(n=iterations; n > 0 ; n--) {
        a2 = (a * a) >> bits;
        b2 = (b * b) >> bits;
        if((a2 + b2) >= (4 << bits)) break;
        b  = posImag + ((a * b) >> (bits - 1));
        a  = posReal + a2 - b2;
      }
      tft.drawPixel(x, y, (n * 29)<<8 | (n * 67));
      // Change the 29/67 to affect colors...
      posReal += incReal;
    }
    posImag -= incImag;
  }

  elapsedTime = millis() - startTime;
  Serial.print("Took ");
  Serial.print(elapsedTime/1000.0); Serial.println(" secs");

  tft.setCursor(2, 10);
  tft.setTextColor(ILI9341_RED);
  tft.setTextSize(2);
  tft.print("Pass Complete: ");
  tft.println(rangeReal);

  while(istouched == false) { // When drawing complete, wait for touch
    istouched = ts.touched();
  }
  if(istouched) {
    tft.fillScreen(ILI9341_BLACK); // Blank screen
    TS_Point p = ts.getPoint();    // Send Touch info to Serial Monitor
    Serial.print("Pressure = ");
    Serial.print(p.z);
    Serial.print(", x = ");
    Serial.print(p.x);
    Serial.print(", y = ");
    Serial.println(p.y);
    rangeReal *= 0.90;              // Zoom in each iteration
    rangeImag *= 0.90;
    istouched = false;              // Reset Touch flag
    if(rangeReal < 1.3) {           // Reset the Zoom
      rangeReal = 3.0;
      rangeImag = 3.0;
    }
  }
}

====================================================================

====================================================================
/* analogMeters.ino
 * Example animated Analog Meters using an ILI9341 240x320 TFT LCD.
 *
 * Needs Font 2 (also Font 4 if using large scale label, see notes.)
 *
 * Make sure all the display driver and pin comnenctions are correct
 * by editting the User_Setup.h file in the TFT_eSPI library folder.
 *
 * #################################################################
 * ## DON'T FORGET TO UPDATE THE User_Setup.h FILE IN THE LIBRARY ##
 * #################################################################
 */

#include <TFT_eSPI.h>          // Hardware-specific Graphics library
#include <SPI.h>

TFT_eSPI tft = TFT_eSPI();     // Invoke custom eSPI library

#define TFT_GREY 0x5AEB
#define LOOP_PERIOD 35         // Display updates every 35ms

float ltx=0;                   // Saved x coord of bottom of Needle
uint16_t osx = 120, osy = 120; // Saved x & y coords
uint32_t updateTime=0;         // Time for next update

int old_analog =  -999;        // Value last displayed Analog
int old_digital = -999;        // Value last displayed Digital

int value[6]     = {  0,  0,  0,  0,  0,  0};
int old_value[6] = { -1, -1, -1, -1, -1, -1};
int d=0;


void setup(void) {
  Serial.begin(57600);

  tft.init();
  tft.setRotation(0);
  tft.fillScreen(TFT_BLACK);    // Clear the screen.

  analogMeter();                // Draw 1 Analog meter.

  byte d=40;
  plotLinear("A0", 0,   160);   // Draw 6 Linear Meters.
  plotLinear("A1", 1*d, 160);
  plotLinear("A2", 2*d, 160);
  plotLinear("A3", 3*d, 160);
  plotLinear("A4", 4*d, 160);
  plotLinear("A5", 5*d, 160);

  updateTime = millis();        // Next update time
}


void loop() {
  if(updateTime <= millis()) {
    updateTime = millis() + LOOP_PERIOD;

    d+=4; if(d >= 360) d=0;

    // value[0] = map(analogRead(A0), 0,1023, 0,100);
    // Test with value from Analogue 0

    // Create a Sine wave for testing.
    value[0] = 50 + 50 * sin((d +   0) * 0.0174532925);
    value[1] = 50 + 50 * sin((d +  60) * 0.0174532925);
    value[2] = 50 + 50 * sin((d + 120) * 0.0174532925);
    value[3] = 50 + 50 * sin((d + 180) * 0.0174532925);
    value[4] = 50 + 50 * sin((d + 240) * 0.0174532925);
    value[5] = 50 + 50 * sin((d + 300) * 0.0174532925);

    //unsigned long t = millis();
    plotPointer();
    plotNeedle(value[0], 0);

    Serial.println(millis()-t); // Print time taken for meter update
  }
}

// -----------------------------------------------------------------
//  Draw the Analog Meter on the screen
// -----------------------------------------------------------------

void analogMeter() {
  // Meter outline
  tft.fillRect(0,0, 239,126, TFT_GREY);
  tft.fillRect(5,3, 230,119, TFT_WHITE);

  tft.setTextColor(TFT_BLACK);  // Text color.
  // Draw ticks every 5 degrees from -50 to +50 degrees.
  // (100 deg. FSD swing)
  for(int i=-50; i < 51; i+=5) { // Long scale tick length.
    int tl=15;

    // Coodinates of tick to draw.
    float sx = cos((i - 90) * 0.0174532925);
    float sy = sin((i - 90) * 0.0174532925);
    uint16_t x0 = sx * (100 + tl) + 120;
    uint16_t y0 = sy * (100 + tl) + 140;
    uint16_t x1 = sx *  100 + 120;
    uint16_t y1 = sy *  100 + 140;

    // Coordinates of next tick for zone fill.
    float sx2 = cos((i + 5 - 90) * 0.0174532925);
    float sy2 = sin((i + 5 - 90) * 0.0174532925);
    int x2 = sx2 * (100 + tl) + 120;
    int y2 = sy2 * (100 + tl) + 140;
    int x3 = sx2 * 100 + 120;
    int y3 = sy2 * 100 + 140;

    // Yellow zone limits.
    //if(i >= -50 && i < 0) {
    //  tft.fillTriangle(x0,y0, x1,y1, x2,y2, TFT_YELLOW);
    //  tft.fillTriangle(x1,y1, x2,y2, x3,y3, TFT_YELLOW);
    //}

    // Green zone limits.
    if(i >= 0 && i < 25) {
      tft.fillTriangle(x0,y0, x1,y1, x2,y2, TFT_GREEN);
      tft.fillTriangle(x1,y1, x2,y2, x3,y3, TFT_GREEN);
    }

    // Orange zone limits.
    if(i >= 25 && i < 50) {
      tft.fillTriangle(x0,y0, x1,y1, x2,y2, TFT_ORANGE);
      tft.fillTriangle(x1,y1, x2,y2, x3,y3, TFT_ORANGE);
    }

    if(i%25 != 0) tl = 8;       // Short scale tick length.

    // Recalculate coords in case tick lenght has changed.
    x0 = sx * (100 + tl) + 120;
    y0 = sy * (100 + tl) + 140;
    x1 = sx * 100 + 120;
    y1 = sy * 100 + 140;

    // Draw tick...
    tft.drawLine(x0,y0, x1,y1, TFT_BLACK);

    // Check if Labels should be drawn, with position tweaks.
    if(i%25 == 0) {             // Calculate Label positions.
      x0 = sx * (100 + tl + 10) + 120;
      y0 = sy * (100 + tl + 10) + 140;
      switch (i/25) {
        case -2: tft.drawCenterString(  "0", x0,y0-12, 2); break;
        case -1: tft.drawCenterString( "25", x0,y0- 9, 2); break;
        case  0: tft.drawCenterString( "50", x0,y0- 6, 2); break;
        case  1: tft.drawCenterString( "75", x0,y0- 9, 2); break;
        case  2: tft.drawCenterString("100", x0,y0-12, 2); break;
      }
    }

    // Now draw the Arc of the scale.
    sx = cos((i + 5 - 90) * 0.0174532925);
    sy = sin((i + 5 - 90) * 0.0174532925);
    x0 = sx * 100 + 120;
    y0 = sy * 100 + 140;
    // Draw scale Arc, don't draw the last part yet...
    if(i < 50) tft.drawLine(x0,y0, x1,y1, TFT_BLACK);
  }

  tft.drawString("%RH", 5+230-40,119-20, 2); // Units, bottom right
  tft.drawCenterString("%RH", 120,70, 4);    // Comment out, font 4
  tft.drawRect(5,3, 230,119, TFT_BLACK);     // Draw Bezel line

  plotNeedle(0,0);              // Put meter needle at 0.
}

// -----------------------------------------------------------------
// Update Needle position:
// This function is blocking while the Needle moves. Time depends on
// ms_delay, 10ms minimizes Needle flicker if text is drawn within
// Needle sweep area. Smaller values OK if text not in sweep area.
// Zero for instant movement, but does not look realistic...
// (NOTE: 100 increments for full Scale deflection)
// -----------------------------------------------------------------

void plotNeedle(int value, byte ms_delay) {
  tft.setTextColor(TFT_BLACK, TFT_WHITE);
  char buf[8]; dtostrf(value, 4, 0, buf);
  tft.drawRightString(buf, 40,119-20, 2);

  // Limit value to emmulate Needle end-stops.
  if(value < -10) value = -10;
  if(value > 110) value = 110;

  // Move the Needle util new value reached.
  while(!(value == old_analog)) {
    if(old_analog < value) old_analog++;
    else old_analog--;
    // Update immediately if delay is 0.
    if(ms_delay == 0) old_analog = value;

    // Map value to angle.
    float sdeg = map(old_analog, -10,110, -150,-30);

    // Calcualte tip of Needle coords.
    float sx = cos(sdeg * 0.0174532925);
    float sy = sin(sdeg * 0.0174532925);

    // Calculate x_delta of Needle start position.
    // (Does not start at pivot point)
    float tx = tan((sdeg + 90) * 0.0174532925);

    // Erase old Needle image.
    tft.drawLine(120+20*ltx-1,140-20, osx-1,osy, TFT_WHITE);
    tft.drawLine(120+20*ltx,  140-20, osx,  osy, TFT_WHITE);
    tft.drawLine(120+20*ltx+1,140-20, osx+1,osy, TFT_WHITE);

    // Re-plot text under Needle.
    tft.setTextColor(TFT_BLACK);
    tft.drawCenterString("%RH", 120,70, 4); // Comment out if font 4

    // Store new Needle end-coords for next erase.
    ltx = tx;
    osx = sx * 98 + 120;
    osy = sy * 98 + 140;

    // Draw the Needle in the new postion, The Magenta makes the
    // needle a bit bolder. Draw 3 lines to thicken needle.
    tft.drawLine(120+20*ltx-1,140-20, osx-1,osy, TFT_RED);
    tft.drawLine(120+20*ltx,  140-20, osx,  osy, TFT_MAGENTA);
    tft.drawLine(120+20*ltx+1,140-20, osx+1,osy, TFT_RED);

    // Slow Needle down slightly as it approaches the new postion.
    if(abs(old_analog - value) < 10) ms_delay += ms_delay/5;
    delay(ms_delay);            // Wait before next update
  }
}

// -----------------------------------------------------------------
//  Draw a Linear Meter on the screen
// -----------------------------------------------------------------

void plotLinear(char *label, int x, int y) {
  int w=36;
  tft.drawRect(x,y, w,155, TFT_GREY);
  tft.fillRect(x+2,y+19, w-3,155-38, TFT_WHITE);
  tft.setTextColor(TFT_CYAN, TFT_BLACK);
  tft.drawCenterString(label, x+w/2,y+2, 2);

  for(int i=0; i < 110; i+=10) {
    tft.drawFastHLine(x+20,y+27+i, 6, TFT_BLACK);
  }
  for(int i=0; i < 110; i+=50) {
    tft.drawFastHLine(x+20,y+27+i, 9, TFT_BLACK);
  }

  tft.fillTriangle(x+3,y+127, x+3+16,y+127, x+3,y+127-5, TFT_RED);
  tft.fillTriangle(x+3,y+127, x+3+16,y+127, x+3,y+127+5, TFT_RED);

  tft.drawCenterString("---", x+w/2,y+155-18, 2);
}

// -----------------------------------------------------------------
//  Adjust 6 Linear Meter pointer positions.
// -----------------------------------------------------------------

void plotPointer(void) {
  int  dy = 187;
  byte pw =  16;

  tft.setTextColor(TFT_GREEN, TFT_BLACK);
  // Move the 6 pointers 1 pixel towards new value...
  for(int i=0; i < 6; i++) {
    char buf[8]; dtostrf(value[i], 4, 0, buf);
    tft.drawRightString(buf, i*40+36-5, 187-27+155-18, 2);

    int dx = 3 + 40 * i;
    if(value[i] <   0) value[i]=0;
    // Limit value to emulate Needle end stops.
    if(value[i] > 100) value[i]=100;

    while(!(value[i] == old_value[i])) {
      dy = 187 + 100 - old_value[i];
      if(old_value[i] > value[i]) {
        tft.drawLine(dx,dy-5, dx+pw,dy, TFT_WHITE);
        old_value[i]--;
        tft.drawLine(dx,dy+6, dx+pw,dy+1, TFT_RED);
      } else {
        tft.drawLine(dx,dy+5, dx+pw,dy, TFT_WHITE);
        old_value[i]++;
        tft.drawLine(dx,dy-6, dx+pw,dy-1, TFT_RED);
      }
    }
  }
}

====================================================================